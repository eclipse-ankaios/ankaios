# Spec macros

The spec derive macro is targeted at modifying prost generated code to ease up the internal implementations.
Currently this crate provides two macros:

* a derive macro that creates spec objects (giving the name to the create)
* a proc macro that updates the prost objects to add custom serialization and deserialization to the prost annotated type

## Spec derive macro

This macro provides the functionality to automatically derive `OrigSpec` objects from an `Orig` custom type.

### Usage of `#[derive(Spec)]`

The Spec derive macro currently supports named structs and enums with unnamed variants
and generates the new struct or enum including the `From` and `TryFrom` implementations to
convert between the new and the original objects.

Scope extensions of the derive macro are possible if a specific use-case requires it.

The following example shows how to use the macro on a struct:

```Rust
#[derive(Spec)]
#[spec_derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
#[spec_type_attr(#[serde(rename = "userAddress")])]
pub struct Address {
    #[spec_mandatory]
    street: Option<String>,
    #[spec_field_attr(#[serde(skip_serializing_if = "Option::is_none")])]
    additional: Option<CustomType>,
    city: String,
    zip: String,
    #[spec_default]
    notes: Option<String>,
    #[spec_default(1)]
    floor: Option<i32>
}
```

where:

* `#[derive(Spec)]` is the derive procedural macro that generates the new AddressSpec struct
* `#[spec_mandatory]` instructs the macro to remove the option in the generated struct and raise an exception during the conversion.
* `#[spec_default]` and `#[spec_default(<value>)]`instructs the macro to remove the option in the generated struct and use a default or specified `<value>` in case of None during the conversion.
* `#[spec_derive(Debug)` adds the `#[derive(Debug)]` derives to the new struct
* `#[spec_type_attr(...)` adds a custom annotation to the new struct
* `#[spec_field_attr(...)` adds a custom annotation to a field of the new struct

The generated `AddressSpec` struct is the following:

```Rust
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
#[serde(rename = "userAddress")]
pub struct AddressSpec {
    street: String, // This is unwrapped using a .ok_or("Informative message ;)")
    #[serde(skip_serializing_if = "Option::is_none")]
    additional: Option<CustomTypeSpec>,
    city: String,
    zip: String,
    notes: String, // This is unwrapped with .unwrap_or_default()
    floor: Option<i32>, // This is unwrapped with .unwrap_or(1)
}
```

**Note** that the macro also changes all custom types to Spec, i.e., `CustomType` -> `CustomTypeSpec`.
Also note that the visibility of the new object is kept the same as the one from the original one.

The Spec macro for enums supports the same helper annotations and additionally can convert an unnamed enum variant to a named one:

```Rust
#[derive(Spec)]
#[spec_derive(Debug, Eq, PartialEq)]
enum MyEnum {
    #[spec_enum_named]
    A(String),
    #[spec_enum_named]
    B(Person),
    C(Box<Person>),
}
```

with a resulting spec enum:

```Rust
#[derive(Debug, Eq, PartialEq)]
enum MyEnumSpec {
    A{a: String},
    B{b: PersonSpec},
    C(Box<PersonSpec>),
}
```

**Note** that the Spec derive macro currently does not support options in the enum variants.

The Spec derive macro also evaluates prost helper annotations in order to properly work with
objects generated by prost from protobuf files.

The supported helper annotations are:

* `#[prost(enumeration = "RestartPolicy", optional, tag = "2")]` where the type of value is changed to the enum specified by prost. This annotation is supported for both structs and enums.
* `#[prost(map = "string, enumeration(AddCondition)", tag = "1")]` where the type of value type of a HashMap entry is changed to the type specified by prost. This annotation is currently only supported for structs.

For a detailed usage example, you can take a look in the [api crate](../api), but beware that the macros annotations there are added in the build code to the generated from proto Rust objects.

## Fix enum (de)serialization macro

This proc macro was needed as prost generates Rust code with fields having the `i32` type instead the intended one and only adds internal prost annotations for how the serialization to and from protobuf shall be done.
As we want to also serialize and deserialize to YAML and JSON for handling Ankaios manifests provided to the Ankaios server and the `ank` CLI, we need some custom serializers and deserializers.

To spare the manual effort on writing these function and annotating accordingly, we wrote the `fix_enum_serialization` proc macro.

### Usage of `fix_enum_serialization`

If you start with the following structure and add the `fix_enum_serialization` annotation:

```Rust
#[spec_macros::fix_enum_serialization]
#[derive(serde::Deserialize, serde::Serialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StateRule {
    #[prost(enumeration = "ReadWriteEnum", tag = "1")]
    pub operation: i32,
    ...
}
```

The resulting code that the Rust compiler will see would look like this:

```Rust
fn read_write_enum_serializer<S>(
    ...
fn read_write_enum_deserializer<'de, D>(
    ...

#[derive(serde::Deserialize, serde::Serialize)]
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct StateRule {
    #[prost(enumeration = "ReadWriteEnum", tag = "1")]
    #[serde(serialize_with = "read_write_enum_serializer", deserialize_with = "read_write_enum_deserializer")])]
    pub operation: i32,
    ...
}
```

and include the automatically written serializer and deserializer for the value.

The `fix_enum_serialization` macro currently supports:

* named structs with
    * `i32` fields
    * `Option<i32>` fields
    * `HashMap<String, i32>` fields
* enums with unnamed variants with only one `i32` field, e.g. `VariantA(i32)`

## Debugging

Debugging procedural macros is not very easy, but still achievable although different compared with debugging production code or tests.

There is a [good article on debugging from ferrous systems](https://ferrous-systems.com/blog/testing-proc-macros/) about testing proc macros in general.
In the following, the basics are summarized for easier entry in the topic:

## Using cargo expand

[Cargo expand](https://github.com/dtolnay/cargo-expand) is a nice way to see the output of the macros without having to add `println`s in the code.
The only problem is the sheer amount of produced output as also the derives for `Clone`, `Debug`, serde, etc. are in the output.

**Note** that you need to be in the `api` crate where the macros are used to be able to run `cargo expand`.

To get a focused results, one has to get a bit creative, e.g., to get the derived struct for the Spec workload `WorkloadSpec` use the following command:

```bash
cargo expand | grep "struct WorkloadSpec {" --before-context 5 --after-context 20
```

Which would output 5 lines before the searched string and 20 lines after.

The same way the `from` implementation can be viewed too:

```bash
cargo expand | grep " From<WorkloadSpec>.*for Workload {" --before-context 5 --after-context 20
```
