# Internal derive macros for automatically generating <>Internal objects

This create provides the functionality to automatically derive `OrigInternal` objects from an `Orig` custom type

## Usage

The Internal derive macro currently supports named structs and enums with unnamed variants
and generates the new struct or enum including the `From` and `TryFrom` implementations to
convert between the new and the original objects.

Scope extensions of the derive macro are possible if a specific use-case requires it.

The following example shows how to use the macro on a struct:

```Rust
#[derive(Internal)]
#[internal_derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
#[internal_type_attr(#[serde(rename = "userAddress")])]
pub struct Address {
    #[internal_mandatory]
    street: Option<String>,
    #[internal_field_attr(#[serde(skip_serializing_if = "Option::is_none")])]
    additional: Option<CustomType>,
    city: String,
    zip: String,
}
```

where:

* `#[derive(Internal)]` is the derive procedural macro that generates the new AddressInternal struct
* `#[internal_mandatory]` instructs the macro to remove the option in the generated struct
* `#[internal_derive(Debug)` adds the `#[derive(Debug)]` derives to the new struct
* `#[internal_type_attr(...)` adds a custom annotation to the new struct
* `#[internal_field_attr(...)` adds a custom annotation to a field of the new struct

The generated `AddressInternal` struct is the following:

```Rust
#[derive(Debug, Clone, Eq, PartialEq, Serialize, Deserialize)]
#[serde(rename = "userAddress")]
pub struct AddressInternal {
    street: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    additional: Option<CustomTypeInternal>,
    city: String,
    zip: String,
}
```

**Note** that the macro also changes all custom types to Internal, i.e., `CustomType` -> `CustomTypeInternal`.
Also note that the visibility of the new object is kept the same as the one from the original one.

The Internal macro for enums supports the same helper annotations and additionally can convert an unnamed enum variant to a named one:

```Rust
#[derive(Internal)]
#[internal_derive(Debug, Eq, PartialEq)]
enum MyEnum {
    #[internal_enum_named]
    A(String),
    #[internal_enum_named]
    B(Person),
    C(Box<Person>),
}
```

with a resulting internal enum:

```Rust
#[derive(Debug, Eq, PartialEq)]
enum MyEnumInternal {
    A{a: String},
    OptionTwo{option_two: PersonInternal},
    C(Box<PersonInternal>),
}
```

**Note** that the internal derive macro currently does not support options in the enum variants.

The Internal derive macro also evaluates prost helper annotations in order to properly work with
objects generated by prost from protobuf files.

The supported helper annotations are:

* `#[prost(enumeration = "RestartPolicy", optional, tag = "2")]` where the type of value is changed to the enum specified by prost. This annotation is supported for both structs and enums.
* `#[prost(map = "string, enumeration(AddCondition)", tag = "1")]` where the type of value type of a HashMap entry is changed to the type specified by prost. This annotation is currently only supported for structs.

For a detailed example 

### Debugging

Debugging procedural macros is not very easy, but still achievable although different compared with debugging production code or tests.

There is a [good article on debugging from ferrous systems](https://ferrous-systems.com/blog/testing-proc-macros/) about testing proc macros in general.
In the following, the basics are summarized for easier entry in the topic:

#### Using cargo expand

[Cargo expand](https://github.com/dtolnay/cargo-expand) is a nice way to see the output of the macros without having to add `println`s in the code.
The only problem is the sheer amount of produced output as also the derives for `Clone`, `Debug`, serde, etc. are in the output.

**Note** that you need to be in the `api` crate where the macros are used to be able to run `cargo expand`.

To get a focused results, one has to get a bit creative, e.g., to get the derived struct for the internal workload `WorkloadInternal` use the following command:

```bash
cargo expand | grep "struct WorkloadInternal {" --before-context 5 --after-context 20
```

Which would output 5 lines before the searched string and 20 lines after.

The same way the `from` implementation can be viewed too:

```bash
cargo expand | grep " From<WorkloadInternal>.*for Workload {" --before-context 5 --after-context 20
```
